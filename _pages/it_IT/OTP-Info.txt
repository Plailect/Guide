---
title: "Informazioni sull'OTP"
permalink: /otp-info.html
lang: it_IT
ref: otp-info
---

L'OTP è una regione di memoria da 0x100 byte costituita da dati apparentemente casuali, collocati all'indirizzo di memoria 0x10012000. Si presume che le chiavi univoche della console siano derivate da questa regione, anche se è ancora sconosciuto esattamente come questo avvenga. Questa regione di memoria è, probabilmente, l'archivio dei dati univoci della console, che è decrittato dal bootrom, ma non potremo sapere precisamente come, finché qualcuno non effettuerà un dump completo del bootrom. Al 33c3 tenutosi nel 2016, è stato rivelato che le bootrom sono state dumpate, e vi sono dei bug, ma sono tuttora sconosciuti.

Prima della versione 3.0.0X, l'indirizzo di memoria 0x10012000 (ovvero l'OTP) era lasciata non protetta e poteva essere dumpata da un attaccante con sufficienti privilegi (esecuzione di codice sul processore arm9).

Dopo la versione 3.0.0-X, Nintendo ha optato di bloccare questa sezione con il registro CFG_SYSPROT9, il quale inoltre blocca il bootloader e viene impostato a pochi secondi dal boot, molto prima che si possa ottenere l'esecuzione del codice. Questo registro può essere impostato solo una volta, e non può essere disattivato fino a quando la console non è del tutto spenta, di conseguenza è impossibile fare dumpare tutto l'OTP su una versione di firmware superiore a 3.0.0-X.

Esiste, tuttavia, un metodo per fare il dump dell'hash dell'OTP sulla versione 9.6.0-X. Dal momento che Kernel9Loader non pulisce il registro SHA_HASH dopo il suo utilizzo, tramite il dump di SHA_HASH otterremo l'hash dell'OTP che è stato trasferito da Kernel9Loader a Kernel9. Inoltre, c'è da tempo una falla dove un reboot del MCU causato dall'i2c non pulirà la RAM come dovrebbe.

Questo rende possibile un attacco basato sull'hardware dove dei dati arbitrari sono scritti nel "nand_sector96+0x10" in un backup della SysNAND e flashati nel dispositivo. Successivamente colleghiamo il i2c in modo che faccia un MCU reboot al nostro comando, scriviamo una payload (che scriverà 0x1000A040 - 0x1000A060 in un file sulla scheda SD) da qualche parte nella memoria del arm9, riempiamo tutta la memoria con un NOP sled seguito da una istruzione JMP che punta al payload. Possiamo quindi fare l'MCU reboot ripetutamente (aumentando ogni volta di 1 il nand_sector96+0x10) fino a quando, secondo una probabilità casuale, il Kernel9Loader salta al payload.

Per via della complessità e dell'hardware aggiuntivo presenti nel metodo descritto sopra, ho deciso di limitare lo scopo di questa guida strettamente all'approccio software del downgrade ad una versione inferiore a 3.0.0-X. La versione 2.1.0-X è stata scelta perché è l'unica versione inferiore alla 3.0.0-X che contiene una versione del browser completamente exploitabile (2.0.0-X ha un browser web parzialmente exploitabile, ma non funzionerebbe per altri motivi).

Questo processo implica il flashing della CTRNAND a 2.1.0-4. Questo è eseguito installando un' immagine CTRNAND pre-costruita contenendo 2.1.0, copiando i vostri file specifici alla console (come moveable.sed e SecureInfo_A) ad essa, per poi correggere i CMACS del database titolo. Sul New 3DS inoltre scambia lo slot di criptazione della CTRNAND e installa un header NCSD dell'Old 3DS nella NAND, permettendo l'avvio del software 2.1.0 esclusivo dell'Old 3DS.